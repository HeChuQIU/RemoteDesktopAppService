@using System.Drawing
@using System.Globalization
@using System.Net.Http
@using System.IO
@using System.Reactive
@using System.Reactive.Linq
@using System.Reactive.Subjects
@using System.Windows.Documents
@using Color = MudBlazor.Color
@using Size = MudBlazor.Size

@inject ISnackbar Snackbar

<MudThemeProvider/>
<MudDialogProvider/>
<MudSnackbarProvider/>

@{
    (string? icon, string text) GetConnectionStateInfo(HubConnectionState state)
    {
        return state switch
        {
            HubConnectionState.Disconnected => (Icons.Material.Filled.LinkOff, "未连接"),
            HubConnectionState.Connected => (Icons.Material.Filled.Link, "已连接"),
            HubConnectionState.Connecting => (null, "连接中"),
            HubConnectionState.Reconnecting => (null, "重连中"),
            _ => throw new ArgumentOutOfRangeException()
        };
    }
}


<MudButton @onclick="Connection"
           Disabled="@(_hubConnection.State is HubConnectionState.Connecting or HubConnectionState.Reconnecting)"
           Variant="Variant.Filled" Color="_hubConnection.State is HubConnectionState.Connected ? Color.Success : Color.Primary">
    <MudGrid Spacing="2" Justify="Justify.Center">
        @{
            var (icon, text) = GetConnectionStateInfo(_hubConnection.State);
            <MudItem>
                @if (icon is not null)
                {
                    <MudIcon Icon="@icon"/>
                }
                else
                {
                    <MudProgressCircular Size="Size.Small" Color="Color.Secondary" Indeterminate="true"/>
                }
            </MudItem>
            <MudItem>
                <span>@text</span>
            </MudItem>
        }
    </MudGrid>
</MudButton>

<MudTextField @bind-Value="@_searchText"
              Label="搜索" Variant="Variant.Outlined"
              Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search"
              Class="pa-2"/>

<MudList>
    @foreach (var item in _localApplicationInfos
                  .Where(a => a.Name.StartsWith(_searchText, true, CultureInfo.CurrentCulture))
                  .OrderBy(a => a.Name))
    {
        var isExists = File.Exists(item.ExecutablePath);
        var isToBeRemote = isExists && item.RemoteApp;

        var backgroundColor = isExists ? (isToBeRemote ? Colors.Green.Lighten5 : Colors.Red.Lighten5) : Colors.Grey.Lighten5;
        <MudListItem Class="pa-2">
            <MudPaper Elevation="3" Class="border-0 border-dashed" Style="@($"background-color:{backgroundColor};")">
                <MudGrid Spacing="2" Justify="Justify.FlexStart" Class="align-center pl-4">
                    <MudItem>
                        @if (isExists)
                        {
                            <MudImage Src="@($"data:image/png;base64,{BitmapToBase64(GetIconFromExe(item.ExecutablePath))}")"/>
                        }
                        else
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Error" Color="Color.Error"/>
                        }
                    </MudItem>
                    <MudItem>
                        <MudStack Spacing="0">
                            @item.Name
                            <MudText Typo="Typo.body2" Style="@($"color:{Colors.Grey.Default};")">@item.ExecutablePath</MudText>
                        </MudStack>
                    </MudItem>
                    <MudItem Class="d-flex flex-grow-1 justify-end">
                        <MudSwitch Disabled="@(!isExists)"
                                   @bind-Value:get="isToBeRemote"
                                   @bind-Value:set="@(b => { item.RemoteApp = b; SetLocalApplicationInfos(); })"
                                   Label=@(isToBeRemote ? "已启用" : "已禁用") Color="Color.Primary">
                        </MudSwitch>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudListItem>
    }
</MudList>

@code {

    readonly HubConnection _hubConnection = new HubConnectionBuilder()
        .WithUrl("http://localhost:5000/hostHub")
        .Build();

    readonly List<LocalApplicationInfo> _localApplicationInfos = new();

    string _searchText = string.Empty;

    protected override void OnInitialized()
    {
        _hubConnection.Closed += async ex =>
        {
            if (ex is not null) Snackbar.Add($"连接断开：{ex.Message}", Severity.Error);
            _localApplicationInfos.Clear();
            await InvokeAsync(StateHasChanged);
        };

        _hubConnection.Reconnected += async connectionId =>
        {
            Snackbar.Add("连接已恢复", Severity.Success);
            await InvokeAsync(StateHasChanged);
        };

        Connection();
    }

    private async Task Connection()
    {
        try
        {
            switch (_hubConnection.State)
            {
                case HubConnectionState.Disconnected:
                    await _hubConnection.StartAsync();
                    await _hubConnection.InvokeAsync("LoadApplications");
                    var apps = await _hubConnection.InvokeAsync<LocalApplicationInfo[]>("GetLocalApplicationInfos");
                    _localApplicationInfos.AddRange(apps);
                    break;
                case HubConnectionState.Connected:
                    await _hubConnection.StopAsync();
                    break;
                case HubConnectionState.Connecting:
                case HubConnectionState.Reconnecting:
                default:
                    break;
            }
        }
        catch (HttpRequestException e)
        {
            _localApplicationInfos.Clear();
            Snackbar.Add(e.Message, Severity.Error);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task SetLocalApplicationInfos()
    {
        await _hubConnection.InvokeAsync("SetLocalApplicationInfos", _localApplicationInfos);
        await _hubConnection.InvokeAsync("SaveApplications");
        await _hubConnection.InvokeAsync("SaveRemoteApplicationToRegistry");
    }

    Bitmap? GetIconFromExe(string filePath)
    {
        return Icon.ExtractAssociatedIcon(filePath)?.ToBitmap();
    }

    string BitmapToBase64(Bitmap? bitmap)
    {
        if (bitmap is null) return string.Empty;
        using var memoryStream = new MemoryStream();
        bitmap.Save(memoryStream, System.Drawing.Imaging.ImageFormat.Png);
        byte[] bitmapBytes = memoryStream.ToArray();
        return Convert.ToBase64String(bitmapBytes);
    }

}